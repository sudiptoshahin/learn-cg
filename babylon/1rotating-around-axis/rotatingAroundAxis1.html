<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Rotating around axis</title>

    <!-- Babylon.js + loaders -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

    <style>
      html,
      body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <canvas id="renderCanvas"></canvas>

    <script>
      // Grab canvas
      const canvas = document.getElementById("renderCanvas");
      // Create engine
      const engine = new BABYLON.Engine(canvas, true);

      // Create scene
      function createScene() {
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color3(0.5, 0.5, 0.5);

        // camera
        const camera = new BABYLON.ArcRotateCamera('camera1', 0, 0, 0, new BABYLON.Vector3(5, 3, 0), scene);
        camera.setPosition(new BABYLON.Vector3(14, 8, -12));
        camera.attachControl(canvas, true);

        // light
        const light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(1, 0.5, 0), scene);
        light.intensity = 0.8;

        // material
        const mat = new BABYLON.StandardMaterial('mat1', scene);
        mat.alpha = 1.0;
        mat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 1.0);
        mat.backFaceCulling = false;

        /** Start Pilot **/
        const body = BABYLON.MeshBuilder.CreateCylinder("body", {
            height: 0.75,
            diameterTop: 0.2,
            diameterBottom: 0.5,
            tesselation: 6,
            subdivisions: 1
        }, scene);
        const arm = BABYLON.MeshBuilder.CreateBox("arm", {
            height: 0.75,
            width: 0.3,
            depth: 0.1875
        }, scene);
        arm.position.x = 0.125;
        const pilot = BABYLON.Mesh.MergeMeshes([body, arm], true);
        /** end of pilot **/

        /** Set Center of Rotation (CoR) position, axis and pilot start position **/
        const CoR_At = new BABYLON.Vector3(1, 3, 2);
        const axis = new BABYLON.Vector3(2, 6, 4);
        const pilotStart = new BABYLON.Vector3(2, 3, 4);
        /** end of CoR **/

        /** Draw Axis and Sphere to show Pivot Position **/
        const axisLine = BABYLON.MeshBuilder.CreateLines('axisLine', {
            points: [CoR_At.add(axis.scale(-50)), CoR_At.add(axis.scale(50))],
            scene
        });
        const sphere = BABYLON.MeshBuilder.CreateSphere('sphere', {diameter: 0.25}, scene);
        sphere.position = CoR_At;
        /** end of draw axis and sphere to show pivot position **/

        /** Parent at Pivot position, position child **/
        const pivot = new BABYLON.TransformNode('root');
        pivot.position = CoR_At;
        pilot.parent = pivot;
        pilot.position = pilotStart;
        /** end of Parent at pivot position **/

        /** Animation of Rotation **/
        // const angle = 0.05;
        // scene.registerAfterRender(() => {
        //     pivot.rotate(axis, angle, BABYLON.Space.WORLD);
        // });

        // for oscillation
        let a = 0;
        const angle = 0.025;
        let axisNormal = axis.normalize();  
        scene.registerAfterRender(() => {
            a += 0.005;
            let sign = Math.cos(a)/Math.abs(Math.cos(a));
            pivot.rotate(axis, angle, BABYLON.Space.LOCAL);
            // moving pilot along axis
            pivot.position = pivot.position.add(axisNoramal.scale(0.01*sign));
            // sphere.position = pilot.position; // set pivot marker position
        });

        /** End of Animation of Rotation **/

        showAxis(8, scene);

        localAxis(3);

        return scene;
      }
      /***** Create and Draw Axis ****/
      function showAxis(size, scene) {
        const makeTextPlane = function(text, color, size) {
            // const dynamicTexture = new BABYLON.DynamicTexture('DynamicTexture', 50, scene, true);
            // dynamicTexture.hasAlpha = true;
            // dynamicTexture.drawText(text, 5, 40, 'bold 36px Arial', color, 'transparent', true);
            const dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
            dynamicTexture.hasAlpha = true;
            dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color , "transparent", true);
            
            const plane = new BABYLON.Mesh.CreatePlane('TextPlane', size, scene, true);
            plane.material = new BABYLON.StandardMaterial('TextPlaneMaterial', scene);
            /**
             * In 3D graphics, each mesh is made of triangles and each triangle has 2 sides
             * 1. Front Face -> the side facing the camera
             * 2. Back Face -> the side facing away from the camera
             * Back-face culling means the GPU will not draw triangles facing away from the camera.
             * **/
            plane.material.backFaceCulling = false;
            plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
            plane.material.diffuseTexture = dynamicTexture;
            return plane;
        }

        // axis-x
        const axisX = BABYLON.Mesh.CreateLines('axisX', [
            new BABYLON.Vector3.Zero(),
            new BABYLON.Vector3(size, 0, 0),
            new BABYLON.Vector3(size*0.95, 0.05*size, 0),
            new BABYLON.Vector3(size, 0, 0),
            new BABYLON.Vector3(size*0.95, -0.05*size, 0)
        ], scene);
        axisX.color = new BABYLON.Color3(1, 0, 0);
        const xChar = makeTextPlane('X', 'red', size/10);
        xChar.position = new BABYLON.Vector3(size+0.3, 0, 0);
        
        // axis-y
        const axisY = BABYLON.Mesh.CreateLines('axisY', [
            new BABYLON.Vector3.Zero(),
            new BABYLON.Vector3(0, size, 0),
            new BABYLON.Vector3(0, size*0.95, 0.05*size),
            new BABYLON.Vector3(0, size, 0),
            new BABYLON.Vector3(0, 0.95*size, -0.05*size)
        ], scene);
        axisY.color = new BABYLON.Color3(0, 1, 0);
        const yChar = makeTextPlane('Y', 'green', size/10);
        yChar.position = new BABYLON.Vector3(0, size+0.3, 0);

        // axis-z
        const axisZ = BABYLON.Mesh.CreateLines('axisZ', [
            new BABYLON.Vector3.Zero(),
            new BABYLON.Vector3(0, 0, size),
            new BABYLON.Vector3(0, -0.05*size, size*0.95),
            new BABYLON.Vector3(0, 0, size),
            new BABYLON.Vector3(0, 0.05*size, size*0.95)
        ], scene);
        axisZ.color = new BABYLON.Color3(0, 0, 1);
        const zChar = makeTextPlane('Z', 'blue', size/10);
        zChar.position = new BABYLON.Vector3(0, 0, size+0.3);
      }
      /*** End of create and Draw Axis ***/

      /**** Local Axis ******/
      function localAxis(size, scene) {
        const local_axisX = BABYLON.MeshBuilder.CreateLines(
            'local_axisX', 
            {
                points: [
                    new BABYLON.Vector3.Zero(),
                    new BABYLON.Vector3(size, 0, 0),
                    new BABYLON.Vector3(size*0.95, 0.05*size, 0),
                    new BABYLON.Vector3(size, 0, 0),
                    new BABYLON.Vector3(size*0.95, -0.05*size, 0)
                ]
            },
            scene
        );
        local_axisX.color = new BABYLON.Color3(1, 0, 0);

        const local_axisY = BABYLON.MeshBuilder.CreateLines(
            'local_axisY',
            { points: [
                new BABYLON.Vector3.Zero(),
                new BABYLON.Vector3(0, size, 0),
                new BABYLON.Vector3(-0.05*size, size*0.95, 0),
                new BABYLON.Vector3(0, size, 0),
                new BABYLON.Vector3(0.05*size, size*0.95, 0)
            ]},
            scene
        );
        local_axisY.color = new BABYLON.Color3(0, 1, 0);

        const local_axisZ = BABYLON.MeshBuilder.CreateLines(
            'local_axisZ',
            {points: [
                new BABYLON.Vector3.Zero(),
                new BABYLON.Vector3(0, 0, size),
                new BABYLON.Vector3(0, -0.05*size, size*0.95),
                new BABYLON.Vector3(0, 0, size),
                new BABYLON.Vector3(0, 0.05*size, size*0.95)
            ]},
            scene
        );
        local_axisZ.color = new BABYLON.Color3(0, 0, 1);

        const local_origin = new BABYLON.TransformNode('local_origin');
        local_axisX.parent = local_origin;
        local_axisY.parent = local_origin;
        local_axisZ.parent = local_origin;
        
        return local_origin;
      }

      /**** End of Local Axis *****/

      const scene = createScene();

      // Render loop
      engine.runRenderLoop(() => {
        scene.render();
      });

      // Resize
      window.addEventListener("resize", () => {
        engine.resize();
      });
    </script>
  </body>
</html>
